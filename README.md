
# Documentaci√≥n del Proyecto

## 1. Metodolog√≠a √Ågil

### üìå Descripci√≥n

Explica brevemente qu√© metodolog√≠a √°gil se est√° utilizando (Scrum, Kanban, SAFe, etc.), los roles principales (Scrum Master, Product Owner, equipo de desarrollo), y la frecuencia de las ceremonias.

üëâ [Ver metodolog√≠a completa](./METHODOLOGY.md)

---

## 2. Estrategia de Ramas (Branching Strategy)

### üìå Descripci√≥n

Describe la estrategia utilizada: Git Flow, Trunk-Based Development, GitHub Flow, etc. Incluye el flujo de ramas (main, develop, feature, release, hotfix) y su prop√≥sito.

üëâ [Ver estrategia de ramas](./BRANCHING_STRATEGY.md)

---

## 3. Sprints

### üìå Sprint 1

* Objetivos principales
* Entregables alcanzados
* Lecciones aprendidas

# FALTA 

### üìå Sprint 2

* Objetivos principales
* Entregables alcanzados
* Lecciones aprendidas

# FALTA 

---

## 4. Infraestructura como C√≥digo (IaC) con Terraform

### üìå Descripci√≥n

* Descripci√≥n del uso de Terraform para gestionar la infraestructura
* M√≥dulos reutilizables creados
* Ejemplos de recursos gestionados (VPC, EC2, S3, RDS, etc.)
* Buenas pr√°cticas aplicadas (remote state, workspaces, etc.)

# FALTA 

---

## 5. Patrones de Dise√±o

### üìå Descripci√≥n General
Los patrones de dise√±o son soluciones reutilizables a problemas comunes en el desarrollo de software. En arquitecturas de microservicios, estos patrones son fundamentales para garantizar la escalabilidad, mantenibilidad y resiliencia del sistema.

## ‚úÖ Patrones Implementados

### Resiliencia

La arquitectura implementada incorpora varios patrones cr√≠ticos para garantizar la resiliencia y estabilidad del sistema:
### Circuit Breaker Pattern

Prop√≥sito: Previene cascadas de fallos entre servicios mediante la implementaci√≥n de un "interruptor" que se activa cuando se detectan errores consecutivos
Implementaci√≥n: Cada microservicio incluye mecanismos de circuit breaker que monitorean las llamadas a servicios externos
Beneficios: Reduce la latencia de respuesta durante fallos y permite que el sistema se recupere gradualmente
Estados: Cerrado (funcionamiento normal), Abierto (bloqueando llamadas), Medio-abierto (probando recuperaci√≥n)

### Bulkhead Pattern

Prop√≥sito: Aislamiento de recursos para prevenir que el fallo de un componente afecte a otros
Implementaci√≥n: Separaci√≥n de pools de conexiones, threads y recursos de memoria entre diferentes servicios
Beneficios: Garantiza que un servicio sobrecargado no comprometa la disponibilidad de otros componentes
Aplicaci√≥n: Implementado a nivel de contenedores en Kubernetes con l√≠mites de recursos definidos


#### Configuraci√≥n

* **External Configuration**: Implementado en Kubernetes y aplicado tambi√©n a `favourite-service` sin necesidad de modificar c√≥digo fuente.

> **Ejemplo de External Configuration en Java:**

```java
public static final String USER_SERVICE_HOST = "http://USER-SERVICE/user-service";
```

#### Otros posibles patrones

* Service Discovery
* API Gateway
* Adapter Pattern
* Strategy Pattern
---

## 6. CI/CD Avanzado

### üìå Descripci√≥n

* Herramientas utilizadas (GitHub Actions, GitLab CI, Jenkins, etc.)
* Pipelines para cada tipo de entorno (dev, staging, prod)
* Integraci√≥n con testing y despliegues autom√°ticos
* Validaciones previas (lint, scan, test)

# FALTA 

---

## 7. Pruebas del Proyecto

### üìå Tipos de pruebas

* ‚úÖ **Unitarias**: Detallar qu√© servicios fueron cubiertos y qu√© frameworks se usaron (JUnit, Mockito, etc.)
* ‚úÖ **Integraci√≥n**: Mencionar qu√© m√≥dulos interact√∫an y c√≥mo se testea
* ‚úÖ **E2E**: Describir herramientas (como Cypress, Selenium) y cobertura
* ‚úÖ **Performance con Locust**: Explicar casos de prueba y m√©tricas

PARA ESTAS PRUEBAS QUE YA FUERON IMPLEMENTADAS Y PROBADAS ANTERIORMENTE POR FAVOR MIRAR EL DOCUMENTO [Ver estrategia de ramas](./README-PROJECT-DOCUMENTACION.md)]


* ‚ùå **Seguridad (OWASP)**: **No implementadas a√∫n**, dejar como pendiente o en backlog

# FALTA 

### üìä Informes de Cobertura

* Herramientas utilizadas (JaCoCo, SonarQube, etc.)
* Porcentaje de cobertura general y por m√≥dulo

# FALTA 

---

## 8. Release notes

# Falta 



---

## 9. Observabilidad y Monitoreo

### üìå Stack de Observabilidad

#### Prometheus y Grafana

* Integraci√≥n con servicios
* Dashboards por servicio
* M√©tricas recolectadas

# FALTA 

# ELK Stack 

## Descripci√≥n General

El ELK Stack (Elasticsearch, Logstash, Kibana) junto con Filebeat proporciona una soluci√≥n completa de logging y an√°lisis de datos. Esta configuraci√≥n se despliega autom√°ticamente en Kubernetes usando Helm charts dentro del pipeline de infraestructura.

## Arquitectura de Componentes

### üîç **Elasticsearch**
- **Funci√≥n**: Motor de b√∫squeda y an√°lisis distribuido
- **Prop√≥sito**: Almacena y indexa los logs para b√∫squedas r√°pidas
- **Configuraci√≥n**: `elasticsearch-values.yaml`

### üìä **Logstash** 
- **Funci√≥n**: Procesador de datos en tiempo real
- **Prop√≥sito**: Recibe, transforma y env√≠a logs a Elasticsearch
- **Configuraci√≥n**: `logstash-values.yaml`

### üìà **Kibana**
- **Funci√≥n**: Interfaz de visualizaci√≥n y an√°lisis
- **Prop√≥sito**: Dashboard para explorar y visualizar datos de Elasticsearch
- **Configuraci√≥n**: `kibana-values.yaml`

### üöÄ **Filebeat**
- **Funci√≥n**: Agente de recolecci√≥n de logs ligero
- **Prop√≥sito**: Recolecta logs de contenedores y los env√≠a a Logstash
- **Configuraci√≥n**: `filebeat-values.yaml`

## Pipeline de Despliegue

### Stage de Despliegue ELK

```groovy
stage('Deploy ELK Stack') {
    when { branch 'master' }
    steps {
        bat '''
            echo "üìä Deploying ELK Stack (Elasticsearch, Logstash, Kibana) and Filebeat..."

            // Agregar repositorio oficial de Elastic
            helm repo add elastic https://helm.elastic.co
            helm repo update

            // Desplegar Elasticsearch
            echo "üì¶ Deploying Elasticsearch..."
            helm upgrade --install elasticsearch elastic/elasticsearch ^
            --namespace logging --create-namespace ^
            -f modules/monitoring/elasticsearch-values.yaml

            // Esperar que Elasticsearch est√© listo
            echo "‚è≥ Waiting for Elasticsearch to be ready..."
            kubectl wait --for=condition=Ready pod -l app=elasticsearch-master ^
            --namespace logging --timeout=600s

            // Desplegar Logstash
            echo "üì¶ Deploying Logstash..."
            helm upgrade --install logstash elastic/logstash ^
            --namespace logging ^
            -f modules/monitoring/logstash-values.yaml

            // Desplegar Kibana
            echo "üì¶ Deploying Kibana..."
            helm upgrade --install kibana elastic/kibana ^
            --namespace logging ^
            -f modules/monitoring/kibana-values.yaml

            // Desplegar Filebeat
            echo "üì¶ Deploying Filebeat..."
            helm upgrade --install filebeat elastic/filebeat ^
            --namespace logging ^
            -f modules/monitoring/filebeat-values.yaml

            echo "‚úÖ ELK Stack and Filebeat deployed successfully!"
        '''
    }
}
```

### Caracter√≠sticas Clave del Pipeline

- **Ejecuci√≥n Condicional**: Solo se ejecuta en la rama `master`
- **Gesti√≥n de Dependencias**: Agrega y actualiza el repositorio de Helm de Elastic
- **Despliegue Secuencial**: Elasticsearch ‚Üí Logstash ‚Üí Kibana ‚Üí Filebeat
- **Verificaci√≥n de Estado**: Espera confirmaci√≥n de que Elasticsearch est√© operativo
- **Namespace Dedicado**: Todos los componentes se despliegan en el namespace `logging`

## Archivos de Configuraci√≥n

### 1. `elasticsearch-values.yaml`
**Prop√≥sito**: Configuraci√≥n de recursos y afinidad para Elasticsearch
```yaml
# Ejemplo de configuraci√≥n
resources:
  requests:
    cpu: "100m"
    memory: "512Mi"
  limits:
    cpu: "1000m"
    memory: "2Gi"
```

### 2. `kibana-values.yaml`
**Prop√≥sito**: Configuraci√≥n de servicio y recursos para Kibana
```yaml
# Ejemplo de configuraci√≥n
service:
  type: NodePort
  port: 5601
resources:
  requests:
    cpu: "100m"
    memory: "256Mi"
```

### 3. `logstash-values.yaml`
**Prop√≥sito**: Configuraci√≥n de pipeline de procesamiento y conexi√≥n con Elasticsearch
- Define variables de entorno y credenciales
- Configura pipeline de procesamiento de logs
- Gestiona certificados de seguridad
- Especifica puertos y recursos

### 4. `filebeat-values.yaml`
**Prop√≥sito**: Configuraci√≥n de recolecci√≥n de logs desde contenedores
- Define rutas de logs de contenedores
- Configura procesadores para metadata de Kubernetes
- Establece conexi√≥n con Logstash como salida

### 5. `values.yaml`
**Prop√≥sito**: Configuraci√≥n del stack de monitoreo completo (Prometheus, Grafana, Alertmanager)
- Configura recursos y almacenamiento
- Define reglas de alertas y notificaciones
- Establece dashboards y ServiceMonitors

## Flujo de Datos

```
[Contenedores] ‚Üí [Filebeat] ‚Üí [Logstash] ‚Üí [Elasticsearch] ‚Üí [Kibana]
```

1. **Filebeat** recolecta logs de contenedores en tiempo real
2. **Logstash** procesa, transforma y enriquece los logs
3. **Elasticsearch** indexa y almacena los logs procesados
4. **Kibana** proporciona visualizaci√≥n y an√°lisis de los datos

## Ventajas y Consideraciones

### ‚úÖ **Beneficios Clave**
- **Automatizaci√≥n**: Despliegue integrado en pipeline CI/CD
- **Escalabilidad**: Preparado para producci√≥n con configuraci√≥n flexible
- **Observabilidad**: Monitoreo completo de logs y m√©tricas con gesti√≥n de seguridad

### ‚ö†Ô∏è **Consideraciones Importantes**
- **Recursos**: Elasticsearch requiere CPU/memoria significativa y almacenamiento persistente
- **Seguridad**: Configurar autenticaci√≥n, cifrado y estrategias de backup
- **Monitoreo**: Supervisar rendimiento y salud del cluster

### üîó **Acceso Post-Despliegue**
**Kibana** (dashboards) | **Elasticsearch** (API REST) | **Logs** (agregaci√≥n autom√°tica)

Esta configuraci√≥n integra observabilidad completa en Kubernetes con despliegue automatizado.
![alt text](image-7.png)

# Dashboards Fundamentales para Monitoreo y Observabilidad

## üìä Categorizaci√≥n por Funci√≥n

### üîç **Trazabilidad y Debugging**
#### Ziplin - Trazabilidad Distribuida
![Zipkin Dashboard](image-6.png)

**Prop√≥sito Principal:**
Visualiza el flujo de requests a trav√©s de tu arquitectura de microservicios, mostrando las conexiones y dependencias entre servicios.

**Por qu√© es cr√≠tico:**
- **Identificaci√≥n de cuellos de botella:** Detecta qu√© servicios introducen latencia en el flujo de requests
- **An√°lisis de dependencias:** Comprende c√≥mo los servicios interact√∫an entre s√≠
- **Troubleshooting de errores:** Localiza r√°pidamente d√≥nde fallan las transacciones distribuidas
- **Optimizaci√≥n de rendimiento:** Identifica oportunidades para mejorar la arquitectura

---

### üö® **Gesti√≥n de Alertas**
#### Grafana - Alertmanager / Overview
![Alertmanager Overview](image-1.png)

**Por qu√© es cr√≠tico:**
Es tu centro de comando centralizado que consolida alertas de m√∫ltiples fuentes (Prometheus, aplicaciones, infraestructura) y te permite gestionar el estado completo: activas, silenciadas y resueltas. Sin este dashboard podr√≠as perderte alertas cr√≠ticas que requieren acci√≥n inmediata, comprometiendo SLAs y tiempos de respuesta a incidentes.

---

### üèóÔ∏è **Monitoreo de Infraestructura Kubernetes**

#### Kubernetes / Compute Resources / Cluster
![Kubernetes Cluster Resources](image-2.png)

**Por qu√© es vital:**
Proporciona una vista panor√°mica del consumo de CPU, memoria y almacenamiento de todo el cl√∫ster, detectando problemas de capacidad antes de que impacten usuarios. Identifica patrones de uso para planificaci√≥n de recursos, previene ca√≠das por saturaci√≥n y optimiza costos mostrando recursos subutilizados.

#### Kubernetes / Compute Resources / Namespace (Pods)
![Kubernetes Namespace Resources](image-3.png)

**Por qu√© es esencial:**
Ofrece granularidad por aplicaci√≥n para saber exactamente qu√© consume cada servicio, identifica aplicaciones problem√°ticas con consumo excesivo y facilita troubleshooting de rendimiento. Permite chargeback y asignaci√≥n de costos por equipo/proyecto, adem√°s de detectar memory leaks y procesos descontrolados.

#### Kubernetes / Compute Resources / Node (Pods)
![Kubernetes Node Resources](image-4.png)

**Por qu√© es fundamental:**
Monitorea la salud individual de cada servidor del cl√∫ster, detectando nodos sobrecargados antes de fallos y identificando problemas de hardware o configuraci√≥n. Permite balanceo proactivo de cargas y es esencial para mantenimiento preventivo eficaz.

---

### üîß **Monitoreo del Sistema de Monitoreo**
#### Prometheus / Overview
![Prometheus Overview](image-5.png)

**Por qu√© es indispensable:**
Monitorea al monitor mismo, asegurando que tu sistema de observabilidad funcione correctamente. Detecta problemas en recolecci√≥n de m√©tricas, verifica evaluaci√≥n correcta de reglas de alertas e identifica cuellos de botella en el propio sistema de monitoreo. Sin m√©tricas confiables, todas las decisiones operativas se vuelven ciegas.

---

## üéØ Flujo de Trabajo Recomendado

### 1. **Verificaci√≥n Diaria**
- **Alertmanager Overview:** Revisar estado de alertas activas
- **Prometheus Overview:** Confirmar que el sistema de monitoreo funciona correctamente

### 2. **An√°lisis de Capacidad**
- **Kubernetes Cluster:** Vista general de recursos del cl√∫ster
- **Kubernetes Namespace:** Identificar aplicaciones con alto consumo
- **Kubernetes Node:** Detectar nodos con problemas

### 3. **Investigaci√≥n de Problemas**
- **Zipkin:** An√°lisis detallado de transacciones distribuidas
- **Kubernetes dashboards espec√≠ficos:** Drill-down en recursos problem√°ticos

---

## üèÜ Prioridades de Monitoreo

### **Cr√≠tico (Revisar m√∫ltiples veces al d√≠a)**
1. Alertmanager Overview
2. Prometheus Overview

### **Importante (Revisar diariamente)**
3. Kubernetes Cluster Resources
4. Kubernetes Node Resources

### **Necesario (Revisar seg√∫n demanda)**
5. Kubernetes Namespace Resources
6. Zipkin Tracing

---

## üìà M√©tricas Clave por Dashboard

### **Alertmanager**
- Alertas activas por severidad
- Tiempo de resoluci√≥n promedio
- Alertas silenciadas

### **Kubernetes Cluster**
- CPU/Memory utilization %
- Storage utilization
- Pod count trends

### **Kubernetes Namespace**
- Resource requests vs limits
- Resource utilization por aplicaci√≥n
- Pod restart frequency

### **Kubernetes Node**
- Node health status
- Resource pressure indicators
- Network and disk I/O

### **Prometheus**
- Scrape success rate
- Query performance
- Storage retention

### **Zipkin**
- Request latency percentiles
- Error rate by service
- Service dependency map`


#### Alertas

* Reglas configuradas
* Notificaciones por canal (Slack, email, etc.)


# FALTA 

#### M√©tricas de negocio



# FALTA 

---
